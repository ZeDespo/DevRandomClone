import asyncio
from hashlib import sha1 as hash_func
import json
import os
import requests
from requests.auth import HTTPBasicAuth
from time import time
from traceback import print_exc
from typing import Optional, Dict

from devrandomclone.decorators import validate_reddit_token
from devrandomclone.errors import EAGAIN, RedditAuthenticationError


class DevRandom:
    """
    A replica of /dev/random using Reddit.com/r/all/new as a source of entropy. This specific url is a fire hose of
    every new post, regardless of which subreddit (similar to a forum) it originates from. Given the constant stream of
    new information, it makes a perfect source to collect noise for random data.

    Since Unix systems both put data into and take data out of /dev/random almost simultaneously across multiple
    threads, the class' main methods will emulate this functionality as best as possible asynchronously.
    Given more time, one could port this program to Go and capitalize on it's powerful concurrency capabilities.

    Please note that in order for this script to work, a Reddit account is required, for Reddit needs the username and
    password of the developer's account to use the API. One must also create a new developer application at
    https://www.Reddit.com/prefs/apps and define the app's name. This will generate a personal use script id and a
    secret key, also required by Reddit to enable use the API.
    """

    __slots__ = ('url', 'entropy_avail', 'pool_size', 'dev_random', 'headers', 'expiry')

    def __init__(self, cred_path: Optional[str] = 'reddit_creds.json'):
        """
        Initialize or read value for variables representing the following files:
        entropy_avail emulates /proc/sys/kernel/random/entropy_avail, which keeps a record of how many bits are in the
        entropy pool.
        pool_size emulates /proc/sys/kernel/random/poolsize, which states the maximum number of bits can be in the
        entropy pool.
        dev_random emulates /dev/random, which contains the data generated by environmental noise.

        Additionally, enables the class to use the Reddit API in order to gather noise.
        :param cred_path: The path to the json file holding Reddit credentials.
        """
        self.url = 'https://oauth.Reddit.com'
        for i, fname in enumerate(('entropy_avail', 'poolsize', 'random',)):
            if not os.path.isfile(fname):
                write_func = 'w+'
                if i == 0:
                    value = '0'
                elif i == 1:
                    value = '4096'  # Same bit size as /dev/random/
                else:
                    value = ''.encode()
                    write_func = 'wb+'
                with open(fname, write_func) as f:
                    f.write(value)
        with open('entropy_avail', 'r') as f:
            self.entropy_avail = int(f.readline())
        with open('poolsize', 'r') as f:
            self.pool_size = int(f.readline())
        with open('random', 'rb') as f:
            self.dev_random = list(f.readline())  # Acts as a stack
        self.headers, self.expiry = self._reddit_access_token(cred_path)

    @validate_reddit_token
    def fill_entropy_pool(self, reddit_limit: Optional[int] = 10) -> None:
        """
        Makes a call to Reddit to gather n number of posts, then hashes the subreddit names in chunks of five to generate
        entropy.
        :param reddit_limit: The number of posts to return from /r/all/new
        :return: Nothing.
        """
        if self.entropy_avail == self.pool_size:
            return
        url = '{}/r/all/new'.format(self.url)
        r = requests.get(url, params={'limit': reddit_limit}, headers=self.headers)
        posts = r.json()['data']['children']
        offset = 0
        while offset < reddit_limit:
            end = offset + 5
            if end > reddit_limit:
                end -= reddit_limit
            b_str = ''.join([posts[i]['data']['subreddit'] for i in range(offset, end)]).encode()
            for byte in hash_func(b_str).digest():
                if self.entropy_avail + 8 <= self.pool_size:
                    self.dev_random.append(byte)
                    self.entropy_avail += 8
            offset += 5

    def read_random(self, bytes_request: int, o_nonblock: Optional[bool] = False) -> bytes or None:
        """
        Pops a certain amount of data from the entropy pool.
        :param bytes_request: The number of bytes of entropy to return.
        :param o_nonblock: Emulates the O_NONBLOCK flag for reading /dev/random on Unix systems. If True, will read from
        the entropy pool, even if the number of bytes requested is not available.
        :return: The bytes popped from the dev_random stack as a byte string. None if not enough bytes are available and
        the o_nonblock flag is disabled
        """
        block = True
        while block:
            entropy_avail_bytes = int(self.entropy_avail / 8)
            if bytes_request > entropy_avail_bytes:
                if o_nonblock and entropy_avail_bytes != 0:
                    bytes_request = entropy_avail_bytes
                    block = False
                elif o_nonblock and entropy_avail_bytes == 0:
                    raise EAGAIN("No bytes available in entropy pool.")
                else:  # Block program until more entropy is generated
                    return None
            else:
                block = False
        data = []
        for _ in range (bytes_request):
            data.append(self.dev_random.pop(-1))
            self.entropy_avail -= 8
        return bytes(data)

    def shut_down(self) -> None:
        """
        Persists the data in self.entropy_avail and self.dev_random to disk prior to stopping the program gracefully.
        :return: Nothing.
        """
        with open('entropy_avail', 'w') as f:
            f.write(str(self.entropy_avail))
        with open('random', 'wb') as f:
            f.write(bytes(self.dev_random))

    @staticmethod
    def _reddit_access_token(cred_path: str) -> (Dict[str, str], int):
        """
        Helper function to both DevRandom's constructor and fill_entropy_pool's wrapper. Given a set of credentials in
        reddit_creds.json, connect to Reddit and receive the access token enabling use of the Reddit API.

        reddit_creds.json will contain the following information:
            username: The developer's username for Reddit.
            password: The developer's password for the Reddit account.
            app_id: The personal use script id underneath the app's name on https://www.Reddit.com/prefs/apps.
            app_name: The name the developer gave the app.
            app_secret: The secret key Reddit assigned the app on https://www.Reddit.com/prefs/apps
        :param cred_path: The path to the json file holding Reddit credentials.
        :return: The headers for connecting to the API and the expiration timestamp when the token will expire, marking
        the need to request a new one.
        """
        with open(cred_path, 'r') as f:
            creds = json.load(f)
        payload = {
            'grant_type': 'password',
            'username': creds['username'],
            'password': creds['password']
        }
        user_agent = '{} by {}'.format(creds['app_name'], creds['username'])
        headers = {'user-agent': user_agent}
        r = requests.post(url='https://www.Reddit.com/api/v1/access_token',
                          data=payload,
                          headers=headers,
                          auth=HTTPBasicAuth(creds['app_id'], creds['app_secret']))
        if r.status_code != 200:
            raise RedditAuthenticationError("Cannot access Reddit with given credentials.")
        response_body = r.json()
        token, expiry = 'bearer {}'.format(response_body['access_token']), response_body['expires_in'] + int(time())
        return {'Authorization': token, 'User-Agent': user_agent}, expiry


async def fill_entropy_pool(random: DevRandom, chunks: int) -> None:
    """
    Continuously fill the entropy pool with hashed Reddit data.
    :param random: The DevRandom class object.
    :param chunks: How many groups of Reddit posts to hash at a time to generate entropy.
    :return: Nothing.
    """
    num_reddit_posts = chunks * 5
    if num_reddit_posts > 100:  # Limit the calls to Reddit
        num_reddit_posts = 100
    while True:
        random.fill_entropy_pool(num_reddit_posts)
        await asyncio.sleep(2)  # Can only make 60 requests to Reddit per minute. Must use sparingly.


async def get_random_data(random: DevRandom, bytes_read: int, force: bool) -> None:
    """
    Continuously pop data from the entropy pool and print it out on the console. Same as if one does `cat /dev/random`
    on the terminal.
    :param random: The DevRandom class object.
    :param bytes_read: The number of bytes to read from the entropy pool.
    :param force: Force a read whether or not there are enough bytes in the entropy pool.
    :return: Nothing.
    """
    print("Random data output:", end='\n\n')
    while True:
        data = random.read_random(bytes_read, o_nonblock=force)
        if data is None:  # o_nonblock is false and need to wait for more entropy to generate
            await asyncio.sleep(3)  # Wait a tinge longer than fill_entropy_pool so we don't drain entropy.
        else:
            print("{}".format(data), end='\n')
            await  asyncio.sleep(1)  # Give brief control back to the entropy generator.


def simulate(bytes_read: Optional[int] = 16, force: Optional[bool] = False, chunks: Optional[int] = 2) -> None:
    """
    Start the DevRandom class and simulate the functionality of /dev/random.
    :param bytes_read: The number of bytes to read from the entropy pool.
    :param force: Force a read whether or not there is enough bytes in the entropy pool.
    :param chunks: How many groups of Reddit posts to hash at a time to generate entropy.
    :return: Nothing.
    """
    random = DevRandom()
    try:
        loop = asyncio.get_event_loop()
        tasks = [fill_entropy_pool(random, chunks), get_random_data(random, bytes_read, force)]
        wait_tasks = asyncio.gather(*tasks)
        loop.run_until_complete(wait_tasks)
        loop.close()
    except Exception as e:
        print_exc(e)
    finally:
        random.shut_down()


if __name__ == '__main__':
    exit()
